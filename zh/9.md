# 第九章 平衡搜索

> 译者：[Abel-Huang](https://github.com/Abel-Huang)

我们之前已经看到二叉搜索树有一个弱点：左右子树趋向于不平衡，因此无法将它们所表示的数据集划分成两个同样大小的部分。我们考虑一下我们可以对此做些什么改进。

当然，我们总是可以通过简单地将所有节点按顺序进行排序，然后重新插入它们以生成一个新的平衡二叉树。然而这种操作需要花费树节点数线性规模的复杂度，并且可以看出在 插入N个元素很难避免退化为$\Theta(N^2)$的复杂度。相比之下，如果数据碰巧以保持树遍历的顺序，则进行N次插入仅需要$\Theta(N\lgN)$的时间。因此，让我们首先看看重新平衡树(或保持平衡)的操作，而不将其拆开并重新构建。

## 9.1 平衡构造：B-树
保持搜索树平衡的另一种方法是始终小心"在一个正确的位置插入新的树节点"，以便树通过构造器保持平衡。数据库社区长期以来一直使用完全符合这个要求的数据结构：*B-tree*。我们将在这里抽象地描述这种数据结构和相关操作，而不是直接给出代码，因为这种数据结构用于实践中大量用于提高速度的存储设备。  
*m阶B-树*是具有以下属性的多叉树：  
   1. 每个节点孩子数最多为m个。
   2. 除根之外的所有节点至少有m/2个子节点(我们也可以说除根节点外的每个节点至少包含⌈m/2⌉个子节点)。
   3. 一个节点的孩子$C_0$, $C_1$, ..., $C_(n-1)$用键$K_1$, ..., $K_(n-1)$标记(认为$K_i$在$C_(i-1)$和$C_i$之间)，其中$k_1$<$k_2$<...<$k_(n-1)$；
   4. B-树是一种搜索树：对于任何一个节点，以$C_i$为根的子树中所有键都严格地小于$K_(i+1)$，并且(对于i > 0)严格地大于$K_i$。
   5. 所有空孩子都出现在树的同一层。

图9.1包含一个4阶排序树的示例。在实际实现中，B-树一般用在在二级存储（如磁盘等）上，根据实际需要读入它们的节点。我们选择m阶树(多叉数)的目的是尽可能快地从二级存储器传输数据。对于磁盘操作而言更关注的是单次磁盘访问所需要时间越小越好，
因此m的值范围越大，从不同节点中读取的时间差异越小。在这种情况下，**m**取的值过小很明显不是一个很好的主意。

我们将用一个被称为**BTreeNode**的结构来表示B-树的节点，并且有如下的定义：  
**B.child(i)**：B-树节点**B**的第*i*个孩子，**0 <= i < m**。  
**B.key(i)**：B-树节点**B**的第*i*个关键字Key，**1 <= i < m**。  
**B.parent()**：B-树节点**B**的父节点。  
**B.index()**：B-树节点**B**的索引*i*，**B == B.parent().child(i)**。  
**B.arity()**：B-树节点**B**的孩子数。

然后，整个B-树由指向根的指针组成，可能还包含一些额外的有用信息，例如B-树当前的大小。

基于属性2和属性5，一个拥有N个关键字的B-树一定有$\Theta(\log_(m/2)N)$层节点。基于属性1，搜索单个节点的关键字需要O(1)时间(保证m为固定值)。因此通过下面的递归算法搜索B-树是一个$\Theta(\lgN)$级别的操作。

```java
    boolean search (BTreeNode B, Key X) {
        if (B is the empty tree)
            return false;
        else {
            Find largest c such that B.key(i) ≤ X, for all 1 ≤ i ≤ c.
            if (c > 0 && X.equals (B.key (c)))
                return true;
            else
                return search (B.child (c), K);
        }
```
![figure_9_1](https://github.com/Abel-Huang/cs61b-textbook-zh/blob/master/zh/img/figure_9_1.png)    
图9.1:  键为整型的4阶B-树示例。圆圈代表空节点，它们出现在树的同一层级。每个节点拥有2到4个子节点，每个节点用于1到3个关键字。每个键都大于其左侧子节点中的所有键，并且小于右侧子节点中的所有键。

### 9.1.1 插入
最初，我们插入B树的底部，就像二叉搜索树一样。但是我们通过节点填充和分离来避免树的深度扩展，防止出现"scrawny"
的情形，即每层树节点过少。这个想法很简单：我们在树的底部找到一个合适的位置来插入给定的键，并执行插入 操作(还添加一个额外的空孩子)。如果这使得节点太大(因为它有**m**个键和**m+1**(空)子节点)，我们会对节点进行分裂，具体的代码在图9.2中。图9.3说明了该过程。

### 9.1.2 删除
从B-树中删除通常比插入操作更复杂，但也不是太糟糕。和之前一样，在真实的产品实现中，为了提升速度会引入更多复杂的内容。为了简单起见，我将描述一种简单，理想化的方法。从插入的工作方式中获得启发，我们首先将待删除的键移动到树的底部(删除很简单)。然后，如果删除后使得原始节点太小，我们将其与兄弟节点合并，拉下用于将两者与父节点分开的关键字。图9.4中的伪代码描述了该过程，如图9.5所示。

![figure_9_2](https://github.com/Abel-Huang/cs61b-textbook-zh/blob/master/zh/img/figure_9_2.jpg)  
图9.2：B-树节点分裂。图9.3是过程示意图。

![figure_9_3](https://github.com/Abel-Huang/cs61b-textbook-zh/blob/master/zh/img/figure_9_3.jpg) 
图9.3：B-树插入操作。在图9.1所示的B-树上进行插入操作，分别插入15，145和35三个关键字。

![figure_9_4](https://github.com/Abel-Huang/cs61b-textbook-zh/blob/master/zh/img/figure_9_4.jpg) 
图9.4：B-树删除操作。图9.5是过程示意图。

![figure_9_5](https://github.com/Abel-Huang/cs61b-textbook-zh/blob/master/zh/img/figure_9_5.jpg) 
图9.5：B-树删除操作。这个示例基于图9.3中的(c)部分。在(a)中，我们删除了关键字25。首先，移动25到底部并与其子节点合并。然后，删除关键字25，如果合并后的节点过大，我们需要进行分裂，并将关键字15提升为父节点。接下来，(b)在(a)删除的基础上，删除关键字10。从底部节点删除10会使该节点变小小，因此我们合并它，从父节点向下移动关键字15。这样会导致父节点变小，因此我们继续进行合并，将关键字35从根节点往下移动，得到最终的树。

### 9.1.3 红黑树：二分查找的(2, 4)树
一般B-树使用的节点实际上是关键字的有序数组。有序4阶B-树(也称为(2,4)树)，这种我们一般也称为红黑树。每一个(2,4)树会被映射成一个特定的二叉树，使得每个(2,4)树节点对应于1-3个二叉搜索树节点组成的小集群。因此，二叉搜索树大致平衡，从根节点到叶子节点的所有路径的长度最多相差2倍。图9.6显示了每个可能的(2,4)节点的表示。在一棵完整树中，我们可以仅在每个群集的根节点中设置布尔值来确定群集的边界。但是，习惯上我们将此布尔值为true的节点（以及空叶节点）描述为“黑色”，将其他节点描述为“红色”。

通过考虑图9.6和（2,4）树的结构，你可以推导出红黑树是二叉搜索树，它还遵循以下约束(在红黑树的标准处理中作为它们的定义)：

A. 根节点和所有（null）叶子节点都是黑色的。

B. 红色节点的子节点都是黑色节点；

C. 从根节点到叶子节点的任何路径都遍历相同数量的黑色节点。

同样，属性B和C表明红黑树是“bushy”的，即红黑树是平衡的。

当然，红黑树的搜索过程与普通的二叉树搜索相同。由于图中所示的(2,4)树和红黑树之间的映射，插入操作和删除操作的算法可以从用于4阶B-树的算法中推导出。红黑树的常用操作的实现通常不直接使用此对应关系，对于基本的操作视作普通的二叉搜索树操作，然后通过旋转重新平衡(参见§9.3)，根据当前节点及其相邻节点的颜色的重新着色。我们不会在这里详述。

## 9.2 字典树
![figure_9_6](https://github.com/Abel-Huang/cs61b-textbook-zh/blob/master/zh/img/figure_9_6.jpg) 
图9.6：


### 9.2.1 基本属性和算法

![figure_9_6](https://github.com/Abel-Huang/cs61b-textbook-zh/blob/master/zh/img/figure_9_6.jpg) 
图9.6：

```java
public abstract class Trie {
    /** The empty Trie. */
    public static final Trie EMPTY = new EmptyTrie();
    
    /** The label at this node. Defined only on leaves. */
    abstract public String label();
    
    /** True if X is in this Trie. */
    public boolean isIn(String x) ...
    
    /** The result of inserting X into this Trie, if it is not
     * already there, and returning this. This trie is
     * unchanged if X is in it already. */
    public Trie insert(String x) ...
    
    /** The result of removing X from this Trie, if it is present.
     * The trie is unchanged if X is not present. */
    public Trie remove(String x) ...
    
    /** True if this Trie is a leaf (containing a single String). */
    abstract public boolean isLeaf();
    
    /** True if this Trie is empty */
    abstract public boolean isEmpty();
    
    /** The child numbered with character K. Requires that this node
     * not be empty. Child 0 corresponds to ✷. */
    abstract public Trie child(int k);
    
    /** Set the child numbered with character K to C. Requires that
     * this node not be empty. (Intended only for internal use. */
    abstract protected void setChild(int k, Trie C);
}
```

```java
    /** True if X is in this Trie. */
    public boolean isIn(String x) {
        Trie P = longestPrefix(x, 0);
        return P.isLeaf() && x.equals(P.label());
    }
    
    /** The node representing the longest prefix of X.substring(K) that
     * matches a String in this trie. */
    private Trie longestPrefix(String x, int k) {
        if (isEmpty() || isLeaf())
            return this;
        int c = nth(x, k);
        if (child(c).isEmpty())
            return this;
        else
            return child(c).longestPrefix(x, k+1);
    }
    
    /** Character K of X, or ✷ if K is off the end of X. */
    static char nth(String x, int k) {
    if (k >= x.length())
        return (char) 0;
    else
        return x.charAt(k);
}
```
### 9.2.2 表示

```java
class EmptyTrie extends Trie {
    public boolean isEmpty() { return true; }
    public boolean isLeaf() { return false; }
    public String label() { throw new Error(...); }
public Trie child(int c) { throw new Error(...); }
    protected void child(int c, Trie T) { throw new Error(...); }
}

class LeafTrie extends Trie {
    private String L;
    
    /** A Trie containing just the string S. */
    LeafTrie(String s) { L = s; }
    
    public boolean isEmpty() { return false; }
    public boolean isLeaf() { return true; }
    public String label() { return L; }
    public Trie child(int c) { return EMPTY; }
    protected void child(int c, Trie T) { throw new Error(...); }
}

class InnerTrie extends Trie {
    // ALPHABETSIZE has to be defined somewhere */
    private Trie[] kids = new kids[ALPHABETSIZE];
    
    /** A Trie with child(K) == T and all other children empty. */
    InnerTrie(int k, Trie T) {
        for (int i = 0; i < kids.length; i += 1)
        kids[i] = EMPTY;
        child(k, T);
    }
    
    public boolean isEmpty() { return false; }
    public boolean isLeaf() { return false; }
    public String label() { throw new Error(...); }
    public Trie child(int c) { return kids[c]; }
    protected void child(int c, Trie T) { kids[c] = T; }
}
```
### 9.2.3 表压缩
```java
class InnerTrie extends Trie {
    private static char[] charMap = new char[’9’+1];
    static {
        charMap[0] = 0;
        charMap[’0’] = 1; charMap[’1’] = 1; ...
    }
    
    public Trie child(int c) { return kids[charMap[c]]; }
    protected void child(int c, Trie T) { kids[charMap[c]] = T; }
}
```
## 9.3 旋转自平衡树

### 9.3.1 AVL树

## 9.4 伸展树

### 9.4.1 分析

## 9.5 跳表